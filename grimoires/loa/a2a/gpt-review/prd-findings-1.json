{
  "verdict": "CHANGES_REQUIRED",
  "summary": "As written, this PRD risks breaking the conservation invariant and/or building an unreconcilable dual-ledger system because it doesn’t define a single source of truth and atomicity boundaries for “earn → budget → spend,” and it introduces event/sequence guarantees that can’t be met with the proposed async emission and multi-writer reality.",
  "blocking_issues": [
    {
      "location": "FR-10 Reconciliation Test Harness + Section 9.3 “conservation across systems”",
      "issue": "The PRD asserts a cross-system conservation check (earned - spent = net) without defining the bridging instrument and accounting semantics between the credit ledger (money) and budget engine (authorization).",
      "why_blocking": "If the budget engine is “spending capacity” (not money), then “spent” in the budget engine is not necessarily a debit of earned funds unless there is an explicit, conserved transfer/lock/burn/mint mechanism. Without a defined bridge (e.g., credit-ledger reservation that mints budget capacity 1:1, or budget spend that finalizes a credit-ledger reservation), the reconciliation will either fail in real operation or force engineers to invent inconsistent semantics that violate the invariant.",
      "fix": "Define the canonical bridge and invariants explicitly in ADR-008 and reference it in FR-10: (a) what event causes budget capacity to be created (e.g., CreditLedger ReservationCreated/Finalized), (b) whether capacity is strictly 1:1 backed by locked credits, (c) what constitutes “spent” (finalized reservation vs. budget consumption), (d) how refunds/releases map, and (e) which system is authoritative for each quantity. Update FR-10 to reconcile conserved quantities (e.g., locked_credits + available_credits + spent_credits) rather than mixing “earned funds” with “capacity” unless they are formally coupled."
    },
    {
      "location": "FR-8 Event Emission from Existing Operations + FR-7 sequence_number requirement",
      "issue": "The PRD requires `sequence_number` to be monotonically increasing per entity while also stating event emission can be async/fire-and-forget and additive to existing writes.",
      "why_blocking": "With async emission, retries, concurrent operations, and potential multi-process writers, you cannot guarantee per-entity monotonic sequence numbers without making event append part of the same transactional boundary (or introducing a dedicated sequencer). If consumers rely on sequence_number for ordering/replay, you’ll get gaps, reordering, or duplicates—breaking cross-system integration and reconciliation.",
      "fix": "Either (1) make economic_events append part of the same DB transaction as the source-of-truth write and generate per-entity sequence via a transactional counter, or (2) drop the monotonic-per-entity requirement and instead specify ordering via (entity_id, sqlite rowid) / (global event_id + occurred_at) plus idempotency keys, or (3) introduce a single-writer/event-outbox pattern with deterministic ordering guarantees. Explicitly specify idempotency and exactly-once vs at-least-once delivery expectations."
    },
    {
      "location": "FR-1 Agent Entity-Specific Parameters + FR-3 Provenance Verification",
      "issue": "“Agents don’t need KYC” conflicts with “Creator account has passed appropriate KYC level for their own earnings” and with payout/settlement flows that may pay the agent directly.",
      "why_blocking": "If an agent can receive payouts (or route value) without KYC, but the creator is KYC’d, you must define whether the agent is a sub-account of the creator (regulated beneficiary = creator) or an independent beneficiary (regulated beneficiary = agent/TBA). Without this, engineers can implement a bypass that is non-compliant or blocks legitimate flows, and it will also affect fee caps, clawbacks, and dispute/hold logic.",
      "fix": "Define the legal/economic beneficiary model for agent accounts in Phase 1: either (A) agent is always a controlled sub-ledger of a KYC’d creator (payout destination = creator; agent only accrues internal credits/spending), or (B) agent can be a payout beneficiary with alternative compliance requirements. Encode this into system_config/entity policy and into payout routing rules."
    },
    {
      "location": "FR-2 Agent Budget Caps and Circuit Breaker + Integration with reserve()/finalize() semantics",
      "issue": "Budget caps are specified as rejecting `reserve()` at 100% but the PRD doesn’t define how this interacts with existing reservation TTL, partial finalization, releases, or concurrent reservations.",
      "why_blocking": "Without a precise definition of what counts toward the 24h cap (reserved amount, finalized amount, or both), you can easily create either (a) a bypass (reserve many small amounts then finalize later), (b) deadlocks (cap hit due to outstanding reserves that later release), or (c) invariant breaks if releases aren’t reflected in the cap accounting. This will cause runaway spending or false positives—core to the PRD’s safety claims.",
      "fix": "Specify cap accounting rules: choose one conserved measure (typically finalized spend) and define treatment of reservations (count at reserve-time with release decrement, or count only at finalize-time). Require idempotent cap updates tied to reservation_id and enforce atomicity with the ledger transaction (or a single authoritative counter in SQLite). Add explicit rules for TTL expiry and release events to decrement cap usage if reserve-time counting is used."
    },
    {
      "location": "FR-4/FR-5/FR-6 Constitutional governance + NFR caching (Redis 60s TTL) + emergency override",
      "issue": "Runtime-configurable constitutional parameters with Redis caching and SQLite fallback can lead to inconsistent enforcement across nodes, especially for safety-critical limits (holds, caps, fee caps), and the PRD doesn’t define consistency requirements or rollout semantics.",
      "why_blocking": "If two workers read different config versions (due to cache TTL, race, or partial activation), you can violate invariants and governance intent (e.g., one node applies 0h hold for agents while another applies 48h; or fee caps differ). This is especially dangerous for settlement/payout rules and can break the 439+ tests nondeterministically.",
      "fix": "Define config consistency model: e.g., config is read from SQLite within the transaction for any money-moving operation; Redis is only a read-through cache with version pinning; activation includes an `active_from` timestamp and a monotonically increasing config_version; operations must record the config_version used. Specify that emergency overrides still produce an immutable audit event and require deterministic application across all workers."
    },
    {
      "location": "FR-1 “instant settlement” + Section 2/4.2 claims “agents can’t dispute”",
      "issue": "Assuming “no dispute” for agents ignores fraud/clawback and error correction flows already present (EarningClawedBack, BonusFlagged) and creates a contradiction with needing deterministic validation.",
      "why_blocking": "Instant settlement without a defined clawback/withhold policy for agents can create irreversible payouts/spend that later must be clawed back, potentially violating conservation or creating negative balances. If the system already supports flagged/withheld states, agent policy must be explicitly defined rather than “no dispute.”",
      "fix": "Define agent settlement policy as “no human dispute window” but still subject to automated fraud/withhold/clawback rules. Specify whether agents can go negative, whether spending is allowed against unsettled/withheld earnings, and how clawbacks propagate to budget capacity (must be part of ADR-008)."
    },
    {
      "location": "FR-11 Phase 2 TBA binding + Phase 1 provenance verification (FR-3)",
      "issue": "Phase 1 requires provenance verification via finnNFT token ID, but Phase 2 introduces TBA binding; the PRD doesn’t define how Phase 1 links an agent to a token without the on-chain binding mechanism.",
      "why_blocking": "Teams can implement incompatible identity keys (token_id vs tba_address vs internal agent_id), causing migration pain and broken provenance checks later. This is a classic “identity anchor” mismatch that breaks authorization and reconciliation.",
      "fix": "Define a stable agent identity anchor now: e.g., (chain_id, contract_address, token_id) as the canonical agent identity in Phase 1, with optional tba_address added in Phase 2. Require all events and tables to carry this canonical identity (or a resolvable mapping) so Phase 2 is additive."
    }
  ],
  "question": "",
  "iteration": 1
}
