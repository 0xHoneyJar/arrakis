{
  "verdict": "CHANGES_REQUIRED",
  "summary": "This plan is close, but several dependency and schema/AC mismatches will cause implementation to fail (migration conflicts, outbox-before-emission ordering, and missing persistence for reconciliation results).",
  "blocking_issues": [
    {
      "location": "Sprint 4 / Task 4.4 (agent_clawback_receivables migration)",
      "issue": "Clawback receivable table is planned as a “047 addendum or included in 047 if not yet merged”, but Sprint 5+ assumes migration ordering is strictly monotonic (047→048→049→050).",
      "why_blocking": "In practice this creates a high risk of migration collision/renumbering or non-monotonic application across environments. If 047 is already shipped, you cannot safely “include in 047”; if you add an unnumbered addendum, you break the stated ordering and can strand deployments with missing tables.",
      "fix": "Create a dedicated new migration (e.g., 051_agent_clawback_receivables.ts) and update the dependency graph + ordering section. Update Task 4.4 acceptance criteria to reference that new migration file explicitly and remove the conditional language."
    },
    {
      "location": "Sprint 4 / Task 4.4 and Sprint 9 / Task 9.2 (conservation formulas)",
      "issue": "Acceptance criteria mixes clawback receivables into credit-lot conservation equations without defining how receivables relate to minted/reserved/consumed lots (double-count risk).",
      "why_blocking": "Engineers won’t be able to implement reconciliation checks consistently: if receivables are treated as “assets” alongside lots, you must specify whether they are derived from lots (reclassification) or represent negative balance/IOU. As written, the equations can be contradictory and will fail tests once implemented.",
      "fix": "In Sprint 4, add explicit ledger semantics: when creating a receivable, what ledger entries (if any) are posted and how does it affect lots? In Sprint 9.2, rewrite reconciliation invariants to match those semantics (e.g., either (A) receivable is off-ledger and conservation is lots-only, with a separate invariant for receivable balances, or (B) receivable is represented by specific ledger accounts/entries and included formally). Update AC to one unambiguous set of equations."
    },
    {
      "location": "Sprint 6 / Task 6.1 (events emitted within same transaction as finalization)",
      "issue": "Task 6.1 requires outbox inserts for AgentBudgetWarning/Exhausted “within same transaction as finalization”, but the outbox table and emitter are not created until Sprint 8.",
      "why_blocking": "You cannot implement or test “outbox insert” semantics before the table/port exists. This will either block Sprint 6 or force a rework later, breaking the single-session constraint.",
      "fix": "Either (1) move Sprint 8 ahead of Sprint 6 (or split outbox migration+emitter earlier), or (2) change Sprint 6 AC to emit via an in-memory/no-op interface and add a Sprint 8 task to backfill wiring + tests. Prefer (1): make Sprint 8 a prerequisite for any task that requires transactional outbox writes."
    },
    {
      "location": "Sprint 8 / Task 8.4 (claim protocol SQL)",
      "issue": "Acceptance criteria uses `UPDATE ... LIMIT 100 RETURNING *` for SQLite claim batching; this is not reliably supported across SQLite versions/configurations in the way implied.",
      "why_blocking": "If the repo’s SQLite version (or driver) doesn’t support UPDATE…RETURNING or LIMIT on UPDATE as used, the dispatcher cannot be implemented as specified and will fail at runtime or in CI.",
      "fix": "Change AC to a SQLite-compatible two-step claim: (a) select candidate rowids (ORDER BY rowid LIMIT 100), (b) update by rowid with a guard `WHERE claimed_by IS NULL AND published_at IS NULL`, then (c) re-select claimed rows by `claimed_by`. Add a test that proves no double-claim under concurrency."
    },
    {
      "location": "Sprint 9 / Task 9.2 (Reconciliation results stored for history queries)",
      "issue": "Task 9.2 requires reconciliation results to be stored for history queries, but there is no migration/task creating a `reconciliation_runs` (or similar) table.",
      "why_blocking": "Sprint 9.3 adds `GET /history` endpoint; without a persistence schema, implementation will stall or devolve into ad-hoc storage, failing acceptance criteria.",
      "fix": "Add a migration in Sprint 9 (or earlier) to create `reconciliation_runs` table (id, started_at, finished_at, status, summary_json, divergence_json, created_at). Update Task 9.2/9.3 AC and tests to assert rows are written and retrievable."
    },
    {
      "location": "Sprint 2 / Task 2.2 vs Sprint 1 / Task 1.1 (state machine vs schema)",
      "issue": "Service AC references `pending_approval` transitions, but Task 2.2 propose() inserts status `'draft'` and there is no explicit task to transition draft→pending_approval (nor an endpoint) before approvals occur.",
      "why_blocking": "Approval flow tests (“propose -> approve -> approve -> cooling_down”) will fail if approve() only works on pending_approval but propose() leaves drafts. The plan doesn’t specify how/when a proposal becomes pending.",
      "fix": "Add explicit behavior: either propose() creates `pending_approval` directly (skipping draft), or add a `submit()` method/endpoint to move draft→pending_approval. Update Task 2.1 interface and Task 2.5 endpoints accordingly, and add unit tests for the transition."
    },
    {
      "location": "Sprint 5 / Task 5.3 (authoritative spend computation)",
      "issue": "AC says `recordFinalizationInTransaction` “computes new spend from authoritative finalizations ledger” but the only authoritative table defined is `agent_budget_finalizations`; there is no defined query/windowing rule for computing spend and no index/task to support it.",
      "why_blocking": "Without a precise computation rule (time window boundaries, inclusion criteria, handling of retries/partial finalizations), implementations will diverge and tests will be flaky—especially around window resets and concurrency.",
      "fix": "Specify exact spend computation in AC: e.g., `SUM(amount_micro) FROM agent_budget_finalizations WHERE account_id=? AND finalized_at >= window_start AND finalized_at < window_start+duration`. Add an index on (account_id, finalized_at). Add tests around boundary times."
    }
  ],
  "question": "",
  "iteration": 1
}
