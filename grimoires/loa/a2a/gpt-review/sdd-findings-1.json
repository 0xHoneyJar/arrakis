{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Core direction is sound (SQLite-authoritative + governance + outbox), but several specified mechanisms are internally inconsistent or non-atomic in ways that will break budget caps, settlement correctness, and governance safety under real retries/concurrency.",
  "blocking_issues": [
    {
      "location": "§4.2 AgentBudgetService — idempotency + finalized-only accounting",
      "issue": "`agent_spending_limits.last_finalize_id` only stores a single reservationId, so idempotency is incorrect for any agent that finalizes more than one reservation per window; retries/out-of-order finalizations will double-count or undercount spend.",
      "why_blocking": "FR-2 requires finalized-only, idempotent accounting with a circuit breaker. With a single last id, the second distinct finalization overwrites the id and a retry of the first will be counted again. This will either prematurely open the circuit (false positives) or allow overspend (false negatives) depending on retry patterns—both are production-failing for an economic safety control.",
      "fix": "Replace `last_finalize_id` with a proper idempotency ledger: e.g., `agent_budget_finalizations(account_id, reservation_id PRIMARY KEY, amount_micro, finalized_at)` and update spend via `INSERT OR IGNORE` + `SELECT SUM(...)` or (better) `INSERT OR IGNORE` then `UPDATE agent_spending_limits SET current_spend_micro = current_spend_micro + ?` only when insert succeeded. Keep it in the same `BEGIN IMMEDIATE` transaction as the finalize (or in the same transaction that marks the reservation finalized) to guarantee exactly-once budget counting per reservation."
    },
    {
      "location": "§4.2 Integration with existing reserve/finalize flow",
      "issue": "Budget enforcement is described as an API/gateway pre-check before `CreditLedgerAdapter.reserve()` with no authoritative in-transaction enforcement; this allows overspend via concurrent requests, alternate callers, or bypass paths that call `reserve()` directly.",
      "why_blocking": "A pre-check is not a control if any other code path can reserve/finalize without it. Even if today only one gateway calls reserve, internal jobs/tests/other endpoints will drift over time. Under concurrency, two requests can both pass `checkBudget()` and then both reserve/finalize, exceeding the cap before the circuit opens. This violates FR-2’s “circuit breaker” intent as a hard safety limit.",
      "fix": "Make the cap enforcement authoritative at the point of finalization (since you intentionally count finalized-only): during finalize, in the same SQLite transaction that marks the reservation finalized, attempt to apply the budget increment with idempotency; if it would exceed cap, either (a) prevent finalize (preferred if product allows) or (b) allow finalize but immediately open circuit and emit an exhaustion event while ensuring subsequent reserves are blocked by an authoritative check that cannot be bypassed (e.g., a shared service wrapper used by all reserve entrypoints, or a DB-enforced guard via a finalize hook). At minimum, require all reserve/finalize entrypoints to go through a single application service that performs the check and is used everywhere (tests included)."
    },
    {
      "location": "§4.4 SettlementService modification — transaction boundaries",
      "issue": "The code sample posts a ledger entry via `this.ledger.postEntry(...)` inside a `db.transaction('IMMEDIATE', async (tx)=>...)` block, but `postEntry` is not shown to use the same `tx`. This risks splitting source-of-truth writes across different transactions/connections.",
      "why_blocking": "Outbox correctness and conservation depend on atomicity: (1) update earning status, (2) post ledger entry, (3) insert economic event must commit or roll back together. If `postEntry` uses its own transaction/connection, you can get: earning marked settled without ledger entry, ledger entry without earning status update, or event emitted without one of the writes—each is a reconciliation divergence and can break payouts/settlement invariants.",
      "fix": "Thread the SQLite transaction handle through all money-moving writes: `ledger.postEntryInTransaction(tx, ...)` (or make `postEntry` accept optional `tx` and require it here). Ensure the outbox insert also uses the same `tx`. Add a test that forces a failure after each step and asserts full rollback (no partial settlement)."
    },
    {
      "location": "§3.1 system_config + §4.1 Governance — config_version monotonicity and uniqueness",
      "issue": "`config_version` is described as “monotonically increasing” and “per-param_key MAX+1”, but the schema does not enforce uniqueness per `(param_key, entity_type, config_version)` nor does it prevent concurrent proposals from selecting the same MAX+1. Also, `idx_system_config_active` only enforces one active row, not version sequencing.",
      "why_blocking": "Governance provenance is used in audits/events and for safe rollouts. If two proposals race and both get the same version, you lose a reliable ordering/provenance key and can’t deterministically reconcile which config was applied. This becomes especially problematic with cooldown activation jobs and emergency overrides.",
      "fix": "Enforce versioning at the database level: add `UNIQUE(param_key, entity_type, config_version)` and allocate versions using a single-row counter table per `(param_key, entity_type)` (or use `INTEGER PRIMARY KEY` surrogate version per key) updated in the same `BEGIN IMMEDIATE` transaction. Alternatively, make `config_version` global monotonic (single sequence) if per-key isn’t required."
    },
    {
      "location": "§3.1 system_config — JSON value typing vs seeded overrides",
      "issue": "Seeded override includes `payout.rate_limit_hours` = `2.4` while `value_json` is stored as TEXT and later treated as numeric (`holdParam.value * 60 * 60 * 1000`). The design does not specify a robust typed decoding/validation layer, and some params are BigInt micro amounts while others are floats/ints/null.",
      "why_blocking": "SQLite doesn’t enforce JSON types here; a malformed or unexpected type (string vs number vs null) will cause runtime exceptions or silent coercions in money-moving code paths (settlement/payout/fraud cooldowns). That can halt settlement jobs or apply wrong holds/limits—production-failing.",
      "fix": "Define a strict parameter schema registry in code: for each `param_key`, specify type (`int`, `decimal`, `bigint_micro`, `duration_seconds`, `nullable`, etc.), validation, and decoding rules. Store normalized representations to avoid floats in critical paths (e.g., store `payout.rate_limit_seconds` as integer seconds instead of hours with decimals). Reject proposals that don’t validate before they can enter approval."
    },
    {
      "location": "§4.3 EconomicEventEmitter / §3.1 economic_events — outbox dispatcher concurrency",
      "issue": "Dispatcher runs with concurrency=3 and polls `WHERE published_at IS NULL ORDER BY rowid LIMIT 100`, then updates `published_at` per row. Without a claim/lease mechanism, multiple workers can publish the same rows concurrently (classic outbox double-dispatch).",
      "why_blocking": "At-least-once is acceptable, but uncontrolled duplicate dispatch at scale can overload consumers and break downstream invariants if any consumer is not perfectly idempotent. The SDD claims `idempotency_key` enables deduplication, but that’s only guaranteed if every consumer implements it correctly; the platform should not amplify duplicates by design.",
      "fix": "Add a claiming step: e.g., columns `dispatch_status` + `claimed_by` + `claimed_at` (or `publish_attempt_id`) and select via `UPDATE ... SET claimed_at=now, claimed_by=? WHERE rowid IN (SELECT rowid ... LIMIT 100) AND published_at IS NULL AND claimed_at IS NULL RETURNING *`. Alternatively, set BullMQ concurrency to 1 for the dispatcher until a claim protocol exists."
    },
    {
      "location": "§4.4 Agent clawback policy — conservation and ledger semantics",
      "issue": "The design states: “If a clawback would create a negative balance, apply up to available balance; remainder recorded as `clawback_shortfall` economic event; future earnings reduced via drip recovery,” but no ledger mechanism is specified to preserve conservation and represent the receivable/negative position.",
      "why_blocking": "Partial clawback without a corresponding accounting entry for the unpaid remainder breaks conservation across the system (you’ve effectively forgiven a liability without representing it). Also, “drip recovery” needs a deterministic ledger representation or it will be inconsistent across retries and reconciliation.",
      "fix": "Model the remainder explicitly in the ledger as a receivable/negative lot or a separate liability account (e.g., `agent_clawback_receivable` per agent/creator) so totals remain conserved. Then implement drip recovery as transfers from future earnings to that receivable with idempotent keys. Update reconciliation to include this account/lot class."
    }
  ],
  "question": null,
  "iteration": 1
}
