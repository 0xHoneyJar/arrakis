{
  "verdict": "CHANGES_REQUIRED",
  "summary": "Mostly implementable, but there are a few hard blockers that will break conservation, idempotency, or security as written (notably the transfer_in lot mint path, missing atomic idempotency handling, and incomplete/incorrect event dual-write semantics).",
  "blocking_issues": [
    {
      "location": "3.2 Modified Tables → credit_lots / PeerTransferService 4.1.2 step 5d / Reconciliation Check 5",
      "issue": "Peer transfers mint a new lot with source_type='transfer_in', which creates new supply unless there is an explicit paired lot debit/burn mechanism; the design only reduces sender lot availability and then mints a fresh recipient lot.",
      "why_blocking": "This violates the core conservation invariant for a lot-based system: reducing available_micro/consumed_micro on sender lots does not reduce original_micro (supply), while minting a new lot increases original_micro (supply). Your reconciliation check only compares transfer_out vs transfer_in ledger sums and transfer_in lots vs transfer_in ledger credits, but it never checks that sender-side lot supply decreased correspondingly. Net result: total original_micro across all lots increases with every transfer, i.e., inflation by design.",
      "fix": "Do NOT mint a new lot for transfers. Implement transfers as lot-to-lot movement (split lots) or as a dedicated 'move value' operation that decreases sender lot original_micro (or creates a negative lot/lot adjustment) while increasing recipient lot original_micro by the same amount within the same transaction. Concretely: (A) introduce a lot_split/lot_move primitive in ICreditLedgerService that reassigns portions of existing lots to the recipient (preserving provenance fields), or (B) create recipient lots but also create matching sender-side lot adjustments that reduce original_micro (not just available/consumed). Update Reconciliation Check 5 to assert global lot supply unchanged by transfers: SUM(original_micro WHERE source_type != transfer_in?) or better: assert SUM(original_micro) is unchanged by transfers and that transfer lots are derived, not minted."
    },
    {
      "location": "4.1 PeerTransferService → Transfer Algorithm steps 1 and 5 (idempotency + BEGIN IMMEDIATE)",
      "issue": "Idempotency is not guaranteed under concurrency because the 'INSERT OR IGNORE' happens outside the BEGIN IMMEDIATE transaction and there is no defined read-after-write behavior to return the existing row when the insert is ignored.",
      "why_blocking": "Two concurrent requests with the same idempotency_key can race: one inserts, the other is ignored, but the ignored path as written does not SELECT the existing transfer row before proceeding. That second request can continue into validation/budget checks and then attempt to execute the transfer again, causing double-spend or inconsistent status updates. This is a classic idempotency race that will surface in production retries.",
      "fix": "Wrap idempotency record creation and lookup inside the same BEGIN IMMEDIATE transaction (or do a single-statement upsert with RETURNING semantics if available). Pattern: BEGIN IMMEDIATE; SELECT transfer by idempotency_key; if exists return; else INSERT transfer row; then proceed with the rest of the transfer steps in the same transaction; finally mark completed/rejected and COMMIT. If you must pre-insert outside the tx, then on 'ignored' you must immediately SELECT and return before any side effects."
    },
    {
      "location": "4.5 EventConsolidationAdapter (dual-write) + 3.2 billing_events deprecated marker + 2.3 'Single dual-write path'",
      "issue": "The adapter claims both writes occur 'in the same transaction context (opts.db)', but BillingEventEmitter.emit() is described as void and legacy emitter query methods are used unchanged; there is no guarantee the legacy emitter supports transactional injection or that both writes are actually atomic.",
      "why_blocking": "If economic_events is authoritative, any non-atomic dual-write can produce irreconcilable divergence: economic_events contains an event that billing_events does not (or vice versa). Since you also keep legacy queries reading billing_events, parts of the system can observe different histories depending on which table they read. This is a data integrity failure during migration, not just a cosmetic mismatch.",
      "fix": "Make dual-write explicitly transactional by requiring a shared DB handle/transaction object for both emitters and enforcing it at the type level (e.g., emitInTransaction(tx, ...) for both). If legacy emitter cannot participate, then you must choose: (A) economic_events only + backfill billing_events asynchronously (but then legacy reads must be cut over), or (B) billing_events only + outbox to economic_events. Do not claim 'same transaction' unless both writes are guaranteed to be in the same SQLite transaction."
    },
    {
      "location": "3.2 Modified Tables → credit_lots source_type constraint / 7.2 Migration notes",
      "issue": "The SDD simultaneously (a) specifies altering SQLite CHECK constraints to add 'tba_deposit' and transfer types, and (b) says the codebase uses application-level validation so follow that pattern; this is contradictory and can block migrations depending on current schema.",
      "why_blocking": "If the existing tables actually have CHECK constraints enforced in SQLite (common in earlier migrations), inserting new source_type/entry_type values will fail at runtime unless the table is rebuilt. If the migration does not rebuild the table, transfers and tba_deposit minting will hard-fail in production. Conversely, if you rebuild tables, you must also recreate indexes/foreign keys exactly or you risk data loss/corruption.",
      "fix": "Decide one path and implement it: either (1) rebuild the affected tables in migration 056 with the expanded CHECK constraints (and explicitly recreate all indexes/FKs), or (2) remove/avoid DB-level CHECK constraints entirely (documented) and ensure application-level validation is the only gate. The SDD must match the actual current schema from migrations 030-055."
    },
    {
      "location": "4.3 TbaDepositBridge → detectAndBridge steps 4-6 and 8 + 6.2 TBA Security",
      "issue": "Deposit bridging is not fully specified for provenance and replay safety: it validates toAddress/chainId/token list but does not require an on-chain proof fetch (receipt/log verification) before minting, despite claiming it will 'Verify against actual on-chain data'.",
      "why_blocking": "Because /api/agent/tba/bridge is a webhook/internal endpoint, a compromised listener or misconfigured service JWT could mint arbitrary credits by submitting fabricated detections. The SDD’s security table claims on-chain verification, but the algorithm does not include it as a required step before mintLot(). This is a direct minting vulnerability.",
      "fix": "Make on-chain verification mandatory in the bridge algorithm before any DB write that can lead to minting: fetch tx receipt, verify status=1, verify log topics match token transfer to escrow, verify amount and fromAddress match, verify blockNumber matches receipt, and only then proceed. Persist a hash of the verified receipt/log index in tba_deposits for audit. If you cannot do RPC verification inline, then require the listener to provide a signed attestation and verify signature + include a secondary verifier job before minting."
    },
    {
      "location": "4.4 AgentGovernanceService → Weight Computation (delegation path) + 3.3 New Constitutional Parameters",
      "issue": "Weight computation depends on a parameter 'governance.agent_weight_source' and delegation state ('delegation_ref', creator delegated totals), but no schema/migration is provided for delegation records or for the missing config key.",
      "why_blocking": "As written, computeAgentWeight cannot be implemented deterministically: there is no table to store delegations, no way to compute 'creator's total delegated weight across all agents', and the referenced config key is not added to CONFIG_SCHEMA/FALLBACKS. This will either crash at runtime or silently default incorrectly, breaking FR-3 governance behavior.",
      "fix": "Add the missing configuration key(s) to CONFIG_SCHEMA/FALLBACKS (e.g., governance.agent_weight_source, governance.fixed_weight_per_agent, governance.reputation_window_seconds, governance.reputation_scale_factor, governance.max_weight_per_agent). If delegation is required, add a delegation table (creator_account_id, agent_account_id, weight, created_at, revoked_at) with uniqueness and indexes, plus rules for updates/revocation. If delegation is not required for this cycle, remove delegation from the SDD and lock weight_source to a supported mode."
    }
  ],
  "question": "",
  "iteration": 1
}
